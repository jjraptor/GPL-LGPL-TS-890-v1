--- qt-everywhere-opensource-src-4.8.2_orig/src/3rdparty/powervr/pvr2d.h	2012-04-27 04:46:12.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.2/src/3rdparty/powervr/pvr2d.h	2012-06-16 13:05:37.533585252 +0900
@@ -1,502 +1,669 @@
-/*!****************************************************************************
-@File          pvr2d.h
-@Title         PVR2D external header file
-@Author        Imagination Technologies
-@Copyright     Copyright (c) by Imagination Technologies Limited.
-				This specification is protected by copyright laws and contains
-				material proprietary to Imagination Technologies Limited.
-				You may use and distribute this specification free of charge for implementing
-				the functionality therein, without altering or removing any trademark, copyright,
-				or other notice from the specification.
-@Platform      Generic
-@Description   PVR2D definitions for PVR2D clients
-******************************************************************************/
-
-
-/******************************************************************************
-Modifications :-
-$Log: pvr2d.h $
-******************************************************************************/
-
-#ifndef _PVR2D_H_
-#define _PVR2D_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* PVR2D Platform-specific definitions */
-#define PVR2D_EXPORT
-#define PVR2D_IMPORT
-
-
-#define PVR2D_REV_MAJOR		2
-#define PVR2D_REV_MINOR		1
-
-typedef enum
-{
-	PVR2D_FALSE = 0,
-	PVR2D_TRUE
-} PVR2D_BOOL;
-
-
-/* error codes */
-typedef enum
-{
-	PVR2D_OK = 0,
-	PVR2DERROR_INVALID_PARAMETER = -1,
-	PVR2DERROR_DEVICE_UNAVAILABLE = -2,
-	PVR2DERROR_INVALID_CONTEXT = -3,
-	PVR2DERROR_MEMORY_UNAVAILABLE = -4,
-	PVR2DERROR_DEVICE_NOT_PRESENT = -5,
-	PVR2DERROR_IOCTL_ERROR = -6,
-	PVR2DERROR_GENERIC_ERROR = -7,
-	PVR2DERROR_BLT_NOTCOMPLETE = -8,
-	PVR2DERROR_HW_FEATURE_NOT_SUPPORTED = -9,
-	PVR2DERROR_NOT_YET_IMPLEMENTED = -10,
-	PVR2DERROR_MAPPING_FAILED = -11
-}PVR2DERROR;
-
-
-/* pixel formats */
-typedef enum
-{
-	PVR2D_1BPP = 0,
-	PVR2D_RGB565,
-	PVR2D_ARGB4444,
-	PVR2D_RGB888,
-	PVR2D_ARGB8888,
-	PVR2D_ARGB1555,
-	PVR2D_ALPHA8,
-	PVR2D_ALPHA4,
-	PVR2D_PAL2,
-	PVR2D_PAL4,
-	PVR2D_PAL8,
-	PVR2D_VGAEMU
-
-}PVR2DFORMAT;
-
-
-/* wrap surface type */
-typedef enum
-{
-	PVR2D_WRAPFLAG_NONCONTIGUOUS = 0,
-	PVR2D_WRAPFLAG_CONTIGUOUS = 1,
-
-}PVR2DWRAPFLAGS;
-
-/* flags for control information of additional blits */
-typedef enum
-{
-	PVR2D_BLIT_DISABLE_ALL					= 0x0000,	/* disable all additional controls */
-	PVR2D_BLIT_CK_ENABLE					= 0x0001,	/* enable colour key */
-	PVR2D_BLIT_GLOBAL_ALPHA_ENABLE			= 0x0002,	/* enable standard global alpha */
-	PVR2D_BLIT_PERPIXEL_ALPHABLEND_ENABLE	= 0x0004,	/* enable per-pixel alpha bleding */
-	PVR2D_BLIT_PAT_SURFACE_ENABLE			= 0x0008,	/* enable pattern surf (disable fill) */
-	PVR2D_BLIT_FULLY_SPECIFIED_ALPHA_ENABLE	= 0x0010,	/* enable fully specified alpha */
-	PVR2D_BLIT_ROT_90						= 0x0020,	/* apply 90 degree rotation to the blt */
-	PVR2D_BLIT_ROT_180						= 0x0040,	/* apply 180 degree rotation to the blt */
-	PVR2D_BLIT_ROT_270						= 0x0080,	/* apply 270 degree rotation to the blt */
-	PVR2D_BLIT_COPYORDER_TL2BR				= 0x0100,	/* copy order overrides */
-	PVR2D_BLIT_COPYORDER_BR2TL				= 0x0200,
-	PVR2D_BLIT_COPYORDER_TR2BL				= 0x0400,
-	PVR2D_BLIT_COPYORDER_BL2TR				= 0x0800,
-	PVR2D_BLIT_COLKEY_SOURCE				= 0x1000,	/* Key colour is on the source surface */
-	PVR2D_BLIT_COLKEY_DEST					= 0x2000	/* Key colour is on the destination surface */
-
-} PVR2DBLITFLAGS;
-
-/* standard alpha-blending functions, AlphaBlendingFunc field of PVR2DBLTINFO */
-typedef enum
-{
-	PVR2D_ALPHA_OP_SRC_DSTINV = 1,	/* source alpha : Cdst = Csrc*Asrc + Cdst*(1-Asrc) */
-	PVR2D_ALPHA_OP_SRCP_DSTINV = 2	/* premultiplied source alpha : Cdst = Csrc + Cdst*(1-Asrc) */
-} PVR2D_ALPHABLENDFUNC;
-
-/* blend ops for fully specified alpha */
-typedef enum
-{
-	PVR2D_BLEND_OP_ZERO = 0,
-	PVR2D_BLEND_OP_ONE = 1,
-	PVR2D_BLEND_OP_SRC = 2,
-	PVR2D_BLEND_OP_DST = 3,
-	PVR2D_BLEND_OP_GLOBAL = 4,
-	PVR2D_BLEND_OP_SRC_PLUS_GLOBAL = 5,
-	PVR2D_BLEND_OP_DST_PLUS_GLOBAL = 6
-}PVR2D_BLEND_OP;
-
-
-typedef void* PVR2D_HANDLE;
-
-
-/* Fully specified alpha blend :	pAlpha field of PVR2DBLTINFO structure					*/
-/* a fully specified Alpha Blend operation is defined as									*/
-/* DST (ALPHA) = (ALPHA_1 * SRC (ALPHA)) + (ALPHA_3 * DST (ALPHA))							*/
-/* DST (RGB)   = (ALPHA_2 * SRC (RGB)) + (ALPHA_4 * DST (RGB))								*/
-/* if the pre-multiplication stage is enabled then the equations become the following:		*/
-/* PRE_MUL     = ((SRC(A)) * (Global Alpha Value))											*/
-/* DST (ALPHA) = (ALPHA_1 * SRC (ALPHA)) + (PRE_MUL * DST (ALPHA))							*/
-/* DST (RGB)   = (ALPHA_2 * SRC (RGB)) + (PRE_MUL * DST (RGB))								*/
-/* if the transparent source alpha stage is enabled then a source alpha of zero forces the	*/
-/* source to be transparent for that pixel regardless of the blend equation being used.		*/
-typedef struct _PVR2D_ALPHABLT
-{
-	PVR2D_BLEND_OP	eAlpha1;
-	PVR2D_BOOL		bAlpha1Invert;
-	PVR2D_BLEND_OP	eAlpha2;
-	PVR2D_BOOL		bAlpha2Invert;
-	PVR2D_BLEND_OP	eAlpha3;
-	PVR2D_BOOL		bAlpha3Invert;
-	PVR2D_BLEND_OP	eAlpha4;
-	PVR2D_BOOL		bAlpha4Invert;
-	PVR2D_BOOL		bPremulAlpha;			/* enable pre-multiplication stage */
-	PVR2D_BOOL		bTransAlpha;			/* enable transparent source alpha stage */
-	PVR2D_BOOL		bUpdateAlphaLookup;		/* enable and update the 1555-Lookup alpha table */
-	unsigned char	uAlphaLookup0;			/* 8 bit alpha when A=0 in a 1555-Lookup surface */
-	unsigned char	uAlphaLookup1;			/* 8 bit alpha when A=1 in a 1555-Lookup surface */
-	unsigned char	uGlobalRGB;				/* Global Alpha Value for RGB, 0=transparent 255=opaque */
-	unsigned char	uGlobalA;				/* Global Alpha Value for Alpha */
-
-} PVR2D_ALPHABLT, *PPVR2D_ALPHABLT;
-
-
-/* surface memory info structure */
-typedef struct _PVR2DMEMINFO
-{
-	void				*pBase;
-	unsigned long		ui32MemSize;
-	unsigned long		ui32DevAddr;
-	unsigned long		ulFlags;
-	void				*hPrivateData;
-	void				*hPrivateMapData;
-
-}PVR2DMEMINFO, *PPVR2DMEMINFO;
-
-
-#define PVR2D_MAX_DEVICE_NAME 20
-
-typedef struct _PVR2DDEVICEINFO
-{
-	unsigned long	ulDevID;
-	char			szDeviceName[PVR2D_MAX_DEVICE_NAME];
-}PVR2DDEVICEINFO;
-
-
-typedef struct _PVR2DISPLAYINFO
-{
-	unsigned long	ulMaxFlipChains;
-	unsigned long	ulMaxBuffersInChain;
-	PVR2DFORMAT		eFormat;
-	unsigned long	ulWidth;
-	unsigned long	ulHeight;
-	long			lStride;
-	unsigned long	ulMinFlipInterval;
-	unsigned long	ulMaxFlipInterval;
-
-}PVR2DDISPLAYINFO;
-
-
-typedef struct _PVR2DBLTINFO
-{
-	unsigned long	CopyCode;			/* rop code  */
-	unsigned long	Colour;				/* fill colour */
-	unsigned long	ColourKey;			/* colour key */
-	unsigned char	GlobalAlphaValue;	/* global alpha blending */
-	unsigned char	AlphaBlendingFunc;	/* per-pixel alpha-blending function */
-
-	PVR2DBLITFLAGS	BlitFlags;			/* additional blit control information */
-
-	PVR2DMEMINFO	*pDstMemInfo;		/* destination memory */
-	unsigned long	DstOffset;			/* byte offset from start of allocation to destination surface pixel 0,0 */
-	long			DstStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
-	long			DstX, DstY;			/* pixel offset from start of dest surface to start of blt rectangle */
-	long			DSizeX,DSizeY;		/* blt size */
-	PVR2DFORMAT		DstFormat;			/* dest format */
-	unsigned long	DstSurfWidth;		/* size of dest surface in pixels */
-	unsigned long	DstSurfHeight;		/* size of dest surface in pixels */
-
-	PVR2DMEMINFO	*pSrcMemInfo;		/* source mem, (source fields are also used for patterns) */
-	unsigned long	SrcOffset;			/* byte offset from start of allocation to src/pat surface pixel 0,0 */
-	long			SrcStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
-	long			SrcX, SrcY;			/* pixel offset from start of surface to start of source rectangle */
-										/* for patterns this is the start offset within the pattern */
-	long			SizeX,SizeY;		/* source rectangle size or pattern size in pixels */
-	PVR2DFORMAT		SrcFormat;			/* source/pattern format */
-	PVR2DMEMINFO	*pPalMemInfo;		/* source/pattern palette memory containing argb8888 colour table */
-	unsigned long	PalOffset;			/* byte offset from start of allocation to start of palette */
-	unsigned long	SrcSurfWidth;		/* size of source surface in pixels */
-	unsigned long	SrcSurfHeight;		/* size of source surface in pixels */
-
-	PVR2DMEMINFO	*pMaskMemInfo;		/* mask memory, 1bpp format implied */
-	unsigned long	MaskOffset;			/* byte offset from start of allocation to mask surface pixel 0,0 */
-	long			MaskStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
-	long			MaskX, MaskY;		/* mask rect top left (mask size = blt size) */
-	unsigned long	MaskSurfWidth;		/* size of mask surface in pixels */
-	unsigned long	MaskSurfHeight;		/* size of mask surface in pixels */
-	
-	PPVR2D_ALPHABLT pAlpha;				/* fully specified alpha blend */
-
-}PVR2DBLTINFO, *PPVR2DBLTINFO;
-
-typedef struct _PVR2DRECT
-{
-	long left, top;
-	long right, bottom;
-} PVR2DRECT;
-
-typedef struct
-{
-	PVR2DMEMINFO	*pSurfMemInfo;		/* surface memory */
-	unsigned long	SurfOffset;			/* byte offset from start of allocation to destination surface pixel 0,0 */
-	long			Stride;				/* signed stride */
-	PVR2DFORMAT		Format;
-	unsigned long	SurfWidth;			/* surface size in pixels */
-	unsigned long	SurfHeight;
-
-} PVR2D_SURFACE, *PPVR2D_SURFACE;
-
-typedef struct
-{
-	unsigned long	*pUseCode;					/* USSE code */
-	unsigned long	UseCodeSize;				/* usse code size in bytes */
-
-} PVR2D_USECODE, *PPVR2D_USECODE;
-
-typedef struct
-{
-	PVR2D_SURFACE			sDst;				/* destination surface */
-	PVR2D_SURFACE			sSrc;				/* source surface */
-	PVR2DRECT				rcDest;				/* destination rectangle */
-	PVR2DRECT				rcSource;			/* source rectangle */
-	PVR2D_HANDLE			hUseCode;			/* custom USE code (NULL implies source copy) */
-	unsigned long			UseParams[2];		/* per-blt params for use code */
-
-} PVR2D_3DBLT, *PPVR2D_3DBLT;
-
-
-#define MAKE_COPY_BLIT(src,soff,dest,doff,sx,sy,dx,dy,sz)
-
-typedef void* PVR2DCONTEXTHANDLE;
-typedef void* PVR2DFLIPCHAINHANDLE;
-
-
-// CopyCode field of PVR2DBLTINFO structure:
-// the CopyCode field of the PVR2DBLTINFO structure should contain a rop3 or rop4 code.
-// a rop3 is an 8 bit code that describes a blt with three inputs : source dest and pattern
-// rop4 is a 16 bit code that describes a blt with four inputs : source dest pattern and mask
-// common rop3 codes are defined below
-// a colour fill blt is processed in the pattern channel as a constant colour with a rop code of 0xF0
-// PVR2D_BLIT_PAT_SURFACE_ENABLE defines whether the pattern channel is a surface or a fill colour.
-// a rop4 is defined by two rop3 codes, and the 1 bit-per-pixel mask surface defines which is used.
-// a common rop4 is 0xAAF0 which is the mask copy blt used for text glyphs.
-// CopyCode is taken to be a rop4 when pMaskMemInfo is non zero, otherwise it is assumed to be a rop3
-// use the PVR2DMASKROP4 macro below to construct a rop4 from two rop3's
-// rop3a is the rop used when mask pixel = 1, and rop3b when mask = 0
-#define PVR2DROP4(rop3b, rop3a)			((rop3b<<8)|rop3a)
-
-/* common rop codes */
-#define PVR2DROPclear				0x00       /* 0 (whiteness) */
-#define PVR2DROPset					0xFF       /* 1 (blackness) */
-#define PVR2DROPnoop				0xAA       /* dst (used for masked blts) */
-
-/* source and  dest rop codes */
-#define PVR2DROPand					0x88       /* src AND dst */
-#define PVR2DROPandReverse			0x44       /* src AND NOT dst */
-#define PVR2DROPcopy				0xCC       /* src (used for source copy and alpha blts) */
-#define PVR2DROPandInverted			0x22       /* NOT src AND dst */
-#define PVR2DROPxor					0x66       /* src XOR dst */
-#define PVR2DROPor					0xEE       /* src OR dst */
-#define PVR2DROPnor					0x11       /* NOT src AND NOT dst */
-#define PVR2DROPequiv				0x99       /* NOT src XOR dst */
-#define PVR2DROPinvert				0x55       /* NOT dst */
-#define PVR2DROPorReverse			0xDD       /* src OR NOT dst */
-#define PVR2DROPcopyInverted		0x33       /* NOT src */
-#define PVR2DROPorInverted			0xBB       /* NOT src OR dst */
-#define PVR2DROPnand				0x77       /* NOT src OR NOT dst */
-
-/* pattern rop codes */
-#define PVR2DPATROPand				0xA0       /* pat AND dst */
-#define PVR2DPATROPandReverse		0x50       /* pat AND NOT dst */
-#define PVR2DPATROPcopy				0xF0       /* pat (used for solid color fills and pattern blts) */
-#define PVR2DPATROPandInverted		0x0A       /* NOT pat AND dst */
-#define PVR2DPATROPxor				0x5A       /* pat XOR dst */
-#define PVR2DPATROPor				0xFA       /* pat OR dst */
-#define PVR2DPATROPnor				0x05       /* NOT pat AND NOT dst */
-#define PVR2DPATROPequiv			0xA5       /* NOT pat XOR dst */
-#define PVR2DPATROPinvert			0x55       /* NOT dst */
-#define PVR2DPATROPorReverse		0xF5       /* pat OR NOT dst */
-#define PVR2DPATROPcopyInverted		0x0F       /* NOT pat */
-#define PVR2DPATROPorInverted		0xAF       /* NOT pat OR dst */
-#define PVR2DPATROPnand				0x5F       /* NOT pat OR NOT dst */
-
-/* common rop4 codes */
-#define PVR2DROP4MaskedCopy              PVR2DROP4(PVR2DROPnoop,PVR2DROPcopy)		/* masked source copy blt (used for rounded window corners etc) */
-#define PVR2DROP4MaskedFill              PVR2DROP4(PVR2DROPnoop,PVR2DPATROPcopy)	/* masked colour fill blt (used for text) */
-
-/* Legacy support */
-#define PVR2DROP3_PATMASK			PVR2DPATROPcopy
-#define PVR2DROP3_SRCMASK			PVR2DROPcopy
-
-/* pixmap memory alignment */
-#define PVR2D_ALIGNMENT_4			4			/* DWORD alignment */
-#define PVR2D_ALIGNMENT_ANY			0			/* no alignment    */
-#define PVR2D_ALIGNMENT_PALETTE		16			/* 16 byte alignment is required for palettes */
-
-/* Heap number for PVR2DGetFrameBuffer */
-#define PVR2D_FB_PRIMARY_SURFACE 0
-
-#define PVR2D_PRESENT_PROPERTY_SRCSTRIDE	(1 << 0)
-#define PVR2D_PRESENT_PROPERTY_DSTSIZE		(1 << 1)
-#define PVR2D_PRESENT_PROPERTY_DSTPOS		(1 << 2)
-#define PVR2D_PRESENT_PROPERTY_CLIPRECTS	(1 << 3)
-#define PVR2D_PRESENT_PROPERTY_INTERVAL		(1 << 4)
-
-
-#define PVR2D_CREATE_FLIPCHAIN_SHARED		(1 << 0)
-#define PVR2D_CREATE_FLIPCHAIN_QUERY		(1 << 1)
-
-/* Functions that the library exports */
-
-PVR2D_IMPORT
-int PVR2DEnumerateDevices(PVR2DDEVICEINFO *pDevInfo);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DCreateDeviceContext(unsigned long ulDevID,
-									PVR2DCONTEXTHANDLE* phContext,
-									unsigned long ulFlags);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DDestroyDeviceContext(PVR2DCONTEXTHANDLE hContext);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DGetDeviceInfo(PVR2DCONTEXTHANDLE hContext,
-							  PVR2DDISPLAYINFO *pDisplayInfo);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DGetScreenMode(PVR2DCONTEXTHANDLE hContext,
-							  PVR2DFORMAT *pFormat,
-							  long *plWidth,
-							  long *plHeight,
-							  long *plStride,
-							  int *piRefreshRate);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DGetFrameBuffer(PVR2DCONTEXTHANDLE hContext,
-							   int nHeap,
-							   PVR2DMEMINFO **ppsMemInfo);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DMemAlloc(PVR2DCONTEXTHANDLE hContext,
-						 unsigned long ulBytes,
-						 unsigned long ulAlign,
-						 unsigned long ulFlags,
-						 PVR2DMEMINFO **ppsMemInfo);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DMemWrap(PVR2DCONTEXTHANDLE hContext,
-						void *pMem,
-						unsigned long ulFlags,
-						unsigned long ulBytes,
-						unsigned long alPageAddress[],
-						PVR2DMEMINFO **ppsMemInfo);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DMemMap(PVR2DCONTEXTHANDLE hContext,
-						unsigned long ulFlags,
-						void *hPrivateMapData,
-						PVR2DMEMINFO **ppsDstMem);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DMemFree(PVR2DCONTEXTHANDLE hContext,
-						PVR2DMEMINFO *psMemInfo);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DBlt(PVR2DCONTEXTHANDLE hContext,
-					PVR2DBLTINFO *pBltInfo);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DBltClipped(PVR2DCONTEXTHANDLE hContext,
-						   PVR2DBLTINFO *pBltInfo,
-						   unsigned long ulNumClipRects,
-						   PVR2DRECT *pClipRects);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DQueryBlitsComplete(PVR2DCONTEXTHANDLE hContext,
-								   PVR2DMEMINFO *pMemInfo,
-								   unsigned int uiWaitForComplete);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DSetPresentBltProperties(PVR2DCONTEXTHANDLE hContext,
-										unsigned long ulPropertyMask,
-										long lSrcStride,
-										unsigned long ulDstWidth,
-										unsigned long ulDstHeight,
-										long lDstXPos,
-										long lDstYPos,
-										unsigned long ulNumClipRects,
-										PVR2DRECT *pClipRects,
-										unsigned long ulSwapInterval);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DPresentBlt(PVR2DCONTEXTHANDLE hContext,
-						   PVR2DMEMINFO *pMemInfo,
-						   long lRenderID);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DCreateFlipChain(PVR2DCONTEXTHANDLE hContext,
-								unsigned long ulFlags,
-								unsigned long ulNumBuffers,
-								unsigned long ulWidth,
-								unsigned long ulHeight,
-								PVR2DFORMAT eFormat,
-								long *plStride,
-								unsigned long *pulFlipChainID,
-								PVR2DFLIPCHAINHANDLE *phFlipChain);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DDestroyFlipChain(PVR2DCONTEXTHANDLE hContext,
-								 PVR2DFLIPCHAINHANDLE hFlipChain);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DGetFlipChainBuffers(PVR2DCONTEXTHANDLE hContext,
-									PVR2DFLIPCHAINHANDLE hFlipChain,
-									unsigned long *pulNumBuffers,
-									PVR2DMEMINFO *psMemInfo[]);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DSetPresentFlipProperties(PVR2DCONTEXTHANDLE hContext,
-										 PVR2DFLIPCHAINHANDLE hFlipChain,
-										 unsigned long ulPropertyMask,
-										 long lDstXPos,
-										 long lDstYPos,
-										 unsigned long ulNumClipRects,
-										 PVR2DRECT *pClipRects,
-										 unsigned long ulSwapInterval);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DPresentFlip(PVR2DCONTEXTHANDLE hContext,
-							PVR2DFLIPCHAINHANDLE hFlipChain,
-							PVR2DMEMINFO *psMemInfo,
-							long lRenderID);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DGetAPIRev(long *lRevMajor, long *lRevMinor);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DLoadUseCode (const PVR2DCONTEXTHANDLE hContext, const unsigned char	*pUseCode,
-									const unsigned long UseCodeSize, PVR2D_HANDLE *pUseCodeHandle);
-PVR2D_IMPORT
-PVR2DERROR PVR2DFreeUseCode (const PVR2DCONTEXTHANDLE hContext, const PVR2D_HANDLE hUseCodeHandle);
-
-PVR2D_IMPORT
-PVR2DERROR PVR2DBlt3D (const PVR2DCONTEXTHANDLE hContext, const PPVR2D_3DBLT pBlt3D);
-
-#ifdef __cplusplus
-}
-#endif 
-
-#endif /* _PVR2D_H_ */
-
-/******************************************************************************
- End of file (pvr2d.h)
-******************************************************************************/
+/**********************************************************************
+*
+* Copyright(c) Imagination Technologies Ltd.
+*
+* The contents of this file are subject to the MIT license as set out below.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+* 
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
+* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+* OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+* 
+* This License is also included in this distribution in the file called 
+* "COPYING".
+* 
+******************************************************************************/
+
+
+
+/******************************************************************************
+Modifications :-
+$Log: pvr2d.h $
+
+ --- Revision Logs Removed --- 
+******************************************************************************/
+
+#ifndef _PVR2D_H_
+#define _PVR2D_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+/* PVR2D Platform-specific definitions */
+#if defined (__linux__)
+#define PVR2D_EXPORT __attribute__((visibility("default")))
+#define PVR2D_IMPORT
+#else
+#define PVR2D_EXPORT
+#define PVR2D_IMPORT
+#endif
+
+/* PVR2D header revision */
+#define PVR2D_REV_MAJOR		3
+#define PVR2D_REV_MINOR		5
+
+/* Basic types */
+typedef enum
+{
+	PVR2D_FALSE = 0,
+	PVR2D_TRUE
+} PVR2D_BOOL;
+
+typedef void* PVR2D_HANDLE;
+
+typedef char             PVR2D_CHAR,	*PVR2D_PCHAR;
+typedef unsigned char    PVR2D_UCHAR,	*PVR2D_PUCHAR;
+typedef int              PVR2D_INT,		*PVR2D_PINT;
+typedef unsigned int     PVR2D_UINT,	*PVR2D_PUINT;
+typedef long             PVR2D_LONG,	*PVR2D_PLONG;
+typedef unsigned long    PVR2D_ULONG,	*PVR2D_PULONG;
+
+typedef void             PVR2D_VOID,	*PVR2D_PVOID;
+
+
+/* error codes */
+typedef enum
+{
+	PVR2D_OK = 0,
+	PVR2DERROR_INVALID_PARAMETER = -1,
+	PVR2DERROR_DEVICE_UNAVAILABLE = -2,
+	PVR2DERROR_INVALID_CONTEXT = -3,
+	PVR2DERROR_MEMORY_UNAVAILABLE = -4,
+	PVR2DERROR_DEVICE_NOT_PRESENT = -5,
+	PVR2DERROR_IOCTL_ERROR = -6,
+	PVR2DERROR_GENERIC_ERROR = -7,
+	PVR2DERROR_BLT_NOTCOMPLETE = -8,
+	PVR2DERROR_HW_FEATURE_NOT_SUPPORTED = -9,
+	PVR2DERROR_NOT_YET_IMPLEMENTED = -10,
+	PVR2DERROR_MAPPING_FAILED = -11
+}PVR2DERROR;
+
+/* 32 bit PVR2D pixel format specifier */
+typedef unsigned long PVR2DFORMAT;
+
+/* Standard PVR2D pixel formats */
+#define	PVR2D_1BPP						0x00UL // 1bpp mask surface or palletized 1 bit source with 2x32 bit CLUT
+#define	PVR2D_RGB565					0x01UL // Common rgb 565 format
+#define	PVR2D_ARGB4444					0x02UL // Common argb 4444 format
+#define	PVR2D_RGB888					0x03UL // Common rgb 888 format (not supported)
+#define	PVR2D_ARGB8888					0x04UL // Common argb 8888 format
+#define	PVR2D_ARGB1555					0x05UL // Common argb 1555 format
+#define	PVR2D_ALPHA8					0x06UL // Alpha-only 8 bit per pixel (used with a constant fill colour)
+#define	PVR2D_ALPHA4					0x07UL // Alpha-only 4 bits per pixel (used with a constant fill colour)
+#define	PVR2D_PAL2						0x08UL // Palletized 2 bit format (requires   4x32 bit CLUT)
+#define	PVR2D_PAL4						0x09UL // Palletized 4 bit format (requires  16x32 bit CLUT)
+#define	PVR2D_PAL8						0x0AUL // Palletized 8 bit format (requires 256x32 bit CLUT)
+#define PVR2D_U8						0x10UL // monochrome unsigned 8 bit
+#define PVR2D_U88						0x11UL // monochrome unsigned 16 bit
+#define PVR2D_S8						0x12UL // signed 8 bit
+#define PVR2D_YUV422_YUYV				0x13UL // YUV 422 low-high byte order Y0UY1V
+#define PVR2D_YUV422_UYVY				0x14UL // YUV 422 low-high byte order UY0VY1
+#define PVR2D_YUV422_YVYU				0x15UL // YUV 422 low-high byte order Y0VY1U
+#define PVR2D_YUV422_VYUY				0x16UL // YUV 422 low-high byte order VY0UY1
+#define PVR2D_YUV420_2PLANE				0x17UL // YUV420 2 Plane
+#define PVR2D_YUV420_3PLANE				0x18UL // YUV420 3 Plane
+#define PVR2D_2101010ARGB				0x19UL // 32 bit 2 10 10 10 
+#define PVR2D_888RSGSBS					0x1AUL
+#define PVR2D_16BPP_RAW					0x1BUL // 16 bit raw (no format conversion)
+#define PVR2D_32BPP_RAW					0x1CUL // 32 bit raw
+#define PVR2D_64BPP_RAW					0x1DUL // 64 bit raw
+#define PVR2D_128BPP_RAW				0x1EUL // 128 bit raw
+
+#define	PVR2D_NO_OF_FORMATS				0x1FUL
+
+/* Format modifier bit field (DstFormat and SrcFormat bits 16..23) */
+#define PVR2D_FORMAT_MASK				0x0000FFFFUL	// PVR2D Format bits
+#define PVR2D_FORMAT_LAYOUT_MASK		0x000F0000UL	// Format layout (strided / twiddled / tiled)
+#define PVR2D_FORMAT_FLAGS_MASK			0x0FF00000UL	// Surface Flags mask
+
+/* Layout */
+#define PVR2D_FORMAT_LAYOUT_SHIFT		16
+#define PVR2D_FORMAT_LAYOUT_STRIDED		0x00000000UL
+#define PVR2D_FORMAT_LAYOUT_TILED		0x00010000UL
+#define PVR2D_FORMAT_LAYOUT_TWIDDLED	0x00020000UL
+
+/*
+	PVR2D_SURFACE_PDUMP
+	This flag requests a surface pdump, to capture the pixel state after host writes.
+	Not needed if the surface state has resulted from previous SGX 2D/3D core writes.
+*/
+#define PVR2D_SURFACE_PDUMP				0x00100000UL	// calls PVRSRVPDumpMem to capture the surface (pdump builds only) 
+
+/*
+	Low level 3D format extension - for blts via the 3D core only.
+	If the top bit of the format field is set then PVR2D reads it as a PVRSRV_PIXEL_FORMAT.
+	The outcome is hardware dependant.
+	There is no guarantee that any specific PVRSRV format will be supported.
+*/
+#define PVR2D_FORMAT_PVRSRV				0x80000000
+
+/* wrap surface type */
+typedef enum
+{
+	PVR2D_WRAPFLAG_NONCONTIGUOUS = 0,
+	PVR2D_WRAPFLAG_CONTIGUOUS = 1,
+
+}PVR2DWRAPFLAGS;
+
+#define	PVR2D_CONTEXT_FLAGS_PRIORITY_MASK			0x00000003
+
+#define	PVR2D_CONTEXT_FLAGS_LOW_PRIORITY_CONTEXT	1
+#define	PVR2D_CONTEXT_FLAGS_NORMAL_PRIORITY_CONTEXT	0
+#define	PVR2D_CONTEXT_FLAGS_HIGH_PRIORITY_CONTEXT	2
+
+/* flags for control information of additional blits */
+typedef enum
+{
+	PVR2D_BLIT_DISABLE_ALL					= 0x00000000,	/* disable all additional controls */
+	PVR2D_BLIT_CK_ENABLE					= 0x00000001,	/* enable colour key */
+	PVR2D_BLIT_GLOBAL_ALPHA_ENABLE			= 0x00000002,	/* enable standard global alpha */
+	PVR2D_BLIT_PERPIXEL_ALPHABLEND_ENABLE	= 0x00000004,	/* enable per-pixel alpha bleding */
+	PVR2D_BLIT_PAT_SURFACE_ENABLE			= 0x00000008,	/* enable pattern surf (disable fill) */
+	PVR2D_BLIT_FULLY_SPECIFIED_ALPHA_ENABLE	= 0x00000010,	/* enable fully specified alpha */
+	PVR2D_BLIT_ROT_90						= 0x00000020,	/* apply 90 degree rotation to the blt */
+	PVR2D_BLIT_ROT_180						= 0x00000040,	/* apply 180 degree rotation to the blt */
+	PVR2D_BLIT_ROT_270						= 0x00000080,	/* apply 270 degree rotation to the blt */
+	PVR2D_BLIT_COPYORDER_TL2BR				= 0x00000100,	/* copy order overrides */
+	PVR2D_BLIT_COPYORDER_BR2TL				= 0x00000200,
+	PVR2D_BLIT_COPYORDER_TR2BL				= 0x00000400,
+	PVR2D_BLIT_COPYORDER_BL2TR				= 0x00000800,
+	PVR2D_BLIT_COLKEY_SOURCE				= 0x00001000,	/* Key colour is on the source surface */
+	PVR2D_BLIT_COLKEY_DEST					= 0x00002000,	/* Key colour is on the destination surface */
+	PVR2D_BLIT_COLKEY_MASKED				= 0x00004000,	/* Mask enabled for colour key */
+	PVR2D_BLIT_COLKEY_OP_PASS				= 0x00008000,	/* Colour key op = pass */
+	PVR2D_BLIT_COLKEY_OP_REJECT				= 0x00010000,	/* Colour key op = reject */
+	PVR2D_BLIT_PATH_2DCORE					= 0x00100000,	/* Blt via dedicated 2D Core or PTLA */
+	PVR2D_BLIT_PATH_3DCORE					= 0x00200000,	/* Blt via 3D Core */
+	PVR2D_BLIT_PATH_SWBLT					= 0x00400000,	/* Blt via host software */
+	PVR2D_BLIT_NO_SRC_SYNC_INFO				= 0x00800000,	/* Dont send a source sync info*/
+	PVR2D_BLIT_ISSUE_STATUS_UPDATES			= 0x01000000,	/* Issue status updates */
+
+} PVR2DBLITFLAGS;
+
+/* standard alpha-blending functions, AlphaBlendingFunc field of PVR2DBLTINFO */
+typedef enum
+{
+	PVR2D_ALPHA_OP_SRC_DSTINV = 1,	/* source alpha : Cdst = Csrc*Asrc + Cdst*(1-Asrc) */
+	PVR2D_ALPHA_OP_SRCP_DSTINV = 2	/* premultiplied source alpha : Cdst = Csrc + Cdst*(1-Asrc) */
+} PVR2D_ALPHABLENDFUNC;
+
+/* blend ops for fully specified alpha (SGX 2D Core only) */
+typedef enum
+{
+	PVR2D_BLEND_OP_ZERO = 0,
+	PVR2D_BLEND_OP_ONE = 1,
+	PVR2D_BLEND_OP_SRC = 2,
+	PVR2D_BLEND_OP_DST = 3,
+	PVR2D_BLEND_OP_GLOBAL = 4,
+	PVR2D_BLEND_OP_SRC_PLUS_GLOBAL = 5,
+	PVR2D_BLEND_OP_DST_PLUS_GLOBAL = 6
+}PVR2D_BLEND_OP;
+
+/* SGX 2D Core Fully specified alpha blend :	pAlpha field of PVR2DBLTINFO structure		*/
+/* a fully specified Alpha Blend operation is defined as									*/
+/* DST (ALPHA) = (ALPHA_1 * SRC (ALPHA)) + (ALPHA_3 * DST (ALPHA))							*/
+/* DST (RGB)   = (ALPHA_2 * SRC (RGB)) + (ALPHA_4 * DST (RGB))								*/
+/* if the pre-multiplication stage is enabled then the equations become the following:		*/
+/* PRE_MUL     = ((SRC(A)) * (Global Alpha Value))											*/
+/* DST (ALPHA) = (ALPHA_1 * SRC (ALPHA)) + (PRE_MUL * DST (ALPHA))							*/
+/* DST (RGB)   = (ALPHA_2 * SRC (RGB)) + (PRE_MUL * DST (RGB))								*/
+/* if the transparent source alpha stage is enabled then a source alpha of zero forces the	*/
+/* source to be transparent for that pixel regardless of the blend equation being used.		*/
+typedef struct _PVR2D_ALPHABLT
+{
+	PVR2D_BLEND_OP	eAlpha1;
+	PVR2D_BOOL		bAlpha1Invert;
+	PVR2D_BLEND_OP	eAlpha2;
+	PVR2D_BOOL		bAlpha2Invert;
+	PVR2D_BLEND_OP	eAlpha3;
+	PVR2D_BOOL		bAlpha3Invert;
+	PVR2D_BLEND_OP	eAlpha4;
+	PVR2D_BOOL		bAlpha4Invert;
+	PVR2D_BOOL		bPremulAlpha;			/* enable pre-multiplication stage */
+	PVR2D_BOOL		bTransAlpha;			/* enable transparent source alpha stage */
+	PVR2D_BOOL		bUpdateAlphaLookup;		/* enable and update the 1555-Lookup alpha table */
+	PVR2D_UCHAR		uAlphaLookup0;			/* 8 bit alpha when A=0 in a 1555-Lookup surface */
+	PVR2D_UCHAR		uAlphaLookup1;			/* 8 bit alpha when A=1 in a 1555-Lookup surface */
+	PVR2D_UCHAR		uGlobalRGB;				/* Global Alpha Value for RGB, 0=transparent 255=opaque */
+	PVR2D_UCHAR		uGlobalA;				/* Global Alpha Value for Alpha */
+
+} PVR2D_ALPHABLT, *PPVR2D_ALPHABLT;
+
+
+/* surface memory info structure */
+typedef struct _PVR2DMEMINFO
+{
+	PVR2D_VOID			*pBase;
+	PVR2D_ULONG			ui32MemSize;
+	PVR2D_ULONG			ui32DevAddr;
+	PVR2D_ULONG			ulFlags;
+	PVR2D_VOID			*hPrivateData;
+	PVR2D_VOID			*hPrivateMapData;
+
+}PVR2DMEMINFO, *PPVR2DMEMINFO;
+
+
+#define PVR2D_MAX_DEVICE_NAME 20
+
+typedef struct _PVR2DDEVICEINFO
+{
+	PVR2D_ULONG		ulDevID;
+	PVR2D_CHAR		szDeviceName[PVR2D_MAX_DEVICE_NAME];
+}PVR2DDEVICEINFO;
+
+
+typedef struct _PVR2DISPLAYINFO
+{
+	PVR2D_ULONG	ulMaxFlipChains;
+	PVR2D_ULONG	ulMaxBuffersInChain;
+	PVR2DFORMAT	eFormat;
+	PVR2D_ULONG	ulWidth;
+	PVR2D_ULONG	ulHeight;
+	PVR2D_LONG	lStride;
+	PVR2D_ULONG	ulMinFlipInterval;
+	PVR2D_ULONG	ulMaxFlipInterval;
+
+}PVR2DDISPLAYINFO;
+
+
+typedef struct _PVR2MISCDISPLAYINFO
+{
+	PVR2D_ULONG ulPhysicalWidthmm;
+	PVR2D_ULONG ulPhysicalHeightmm;
+	PVR2D_ULONG ulUnused[10];
+
+}PVR2DMISCDISPLAYINFO;
+
+
+typedef struct _PVR2DBLTINFO
+{
+	PVR2D_ULONG		CopyCode;			/* rop code  */
+	PVR2D_ULONG		Colour;				/* fill colour */
+	PVR2D_ULONG		ColourKey;			/* colour key argb8888 (see CKEY_ defs below) */
+	PVR2D_UCHAR		GlobalAlphaValue;	/* global alpha blending */
+	PVR2D_UCHAR		AlphaBlendingFunc;	/* per-pixel alpha-blending function */
+
+	PVR2DBLITFLAGS	BlitFlags;			/* additional blit control information */
+
+	PVR2DMEMINFO	*pDstMemInfo;		/* destination memory */
+	PVR2D_ULONG		DstOffset;			/* byte offset from start of allocation to destination surface pixel 0,0 */
+	PVR2D_LONG		DstStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
+	PVR2D_LONG		DstX, DstY;			/* pixel offset from start of dest surface to start of blt rectangle */
+	PVR2D_LONG		DSizeX,DSizeY;		/* blt size */
+	PVR2DFORMAT		DstFormat;			/* dest format */
+	PVR2D_ULONG		DstSurfWidth;		/* size of dest surface in pixels */
+	PVR2D_ULONG		DstSurfHeight;		/* size of dest surface in pixels */
+
+	PVR2DMEMINFO	*pSrcMemInfo;		/* source mem, (source fields are also used for patterns) */
+	PVR2D_ULONG		SrcOffset;			/* byte offset from start of allocation to src/pat surface pixel 0,0 */
+	PVR2D_LONG		SrcStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
+	PVR2D_LONG		SrcX, SrcY;			/* pixel offset from start of surface to start of source rectangle */
+										/* for patterns this is the start offset within the pattern */
+	PVR2D_LONG		SizeX,SizeY;		/* source rectangle size or pattern size in pixels */
+	PVR2DFORMAT		SrcFormat;			/* source/pattern format */
+	PVR2DMEMINFO	*pPalMemInfo;		/* source/pattern palette memory containing argb8888 colour table */
+	PVR2D_ULONG		PalOffset;			/* byte offset from start of allocation to start of palette */
+	PVR2D_ULONG		SrcSurfWidth;		/* size of source surface in pixels */
+	PVR2D_ULONG		SrcSurfHeight;		/* size of source surface in pixels */
+
+	PVR2DMEMINFO	*pMaskMemInfo;		/* mask memory, 1bpp format implied */
+	PVR2D_ULONG		MaskOffset;			/* byte offset from start of allocation to mask surface pixel 0,0 */
+	PVR2D_LONG		MaskStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
+	PVR2D_LONG		MaskX, MaskY;		/* mask rect top left (mask size = blt size) */
+	PVR2D_ULONG		MaskSurfWidth;		/* size of mask surface in pixels */
+	PVR2D_ULONG		MaskSurfHeight;		/* size of mask surface in pixels */
+	
+	PPVR2D_ALPHABLT pAlpha;				/* fully specified alpha blend (2DCore only) */
+	
+	PVR2D_ULONG		uSrcChromaPlane1;	/* mem offset from start of source alloc to chroma plane 1 */
+	PVR2D_ULONG		uSrcChromaPlane2;	/* mem offset from start of source alloc to chroma plane 2 */
+	PVR2D_ULONG		uDstChromaPlane1;	/* mem offset from start of dest alloc to chroma plane 1 */
+	PVR2D_ULONG		uDstChromaPlane2;	/* mem offset from start of dest alloc to chroma plane 2 */
+	
+	PVR2D_ULONG		ColourKeyMask;		/* 32 bit colour key mask, only valid when PVR2D_BLIT_COLKEY_MASKED is set */
+
+}PVR2DBLTINFO, *PPVR2DBLTINFO;
+
+typedef struct _PVR2DRECT
+{
+	PVR2D_LONG left, top;
+	PVR2D_LONG right, bottom;
+} PVR2DRECT;
+
+typedef struct
+{
+	PVR2DMEMINFO	*pSurfMemInfo;		/* surface memory */
+	PVR2D_ULONG		SurfOffset;			/* byte offset from start of allocation to destination surface pixel 0,0 */
+	PVR2D_LONG		Stride;				/* signed stride */
+	PVR2DFORMAT		Format;				/* format */
+	PVR2D_ULONG		SurfWidth;			/* surface width in pixels */
+	PVR2D_ULONG		SurfHeight;			/* surface height in pixels */
+
+} PVR2D_SURFACE, *PPVR2D_SURFACE;
+
+typedef struct
+{
+	PVR2D_ULONG		uChromaPlane1;		/* YUV multiplane - byte offset from start of alloc to chroma plane 1 */
+	PVR2D_ULONG		uChromaPlane2;		/* YUV multiplane - byte offset from start of alloc to chroma plane 2 */
+	PVR2D_LONG		Reserved[2];		/* Reserved, must be zero */
+
+} PVR2D_SURFACE_EXT, *PPVR2D_SURFACE_EXT;
+
+typedef struct
+{
+	PVR2D_ULONG		*pUseCode;					/* USSE code */
+	PVR2D_ULONG		UseCodeSize;				/* usse code size in bytes */
+
+} PVR2D_USECODE, *PPVR2D_USECODE;
+
+typedef struct
+{
+	PVR2D_SURFACE			sDst;				/* destination surface */
+	PVR2D_SURFACE			sSrc;				/* source surface */
+	PVR2DRECT				rcDest;				/* destination rectangle */
+	PVR2DRECT				rcSource;			/* source rectangle */
+	PVR2D_HANDLE			hUseCode;			/* custom USE code (NULL implies source copy) */
+	PVR2D_ULONG				UseParams[2];		/* per-blt params for use code */
+
+} PVR2D_3DBLT, *PPVR2D_3DBLT;
+
+typedef struct
+{
+	PVR2D_SURFACE			sDst;						/* destination surface */
+	PVR2DRECT				rcDest;						/* destination rectangle; scaling is supported */
+	PVR2D_SURFACE			sSrc;						/* source surface */
+	PVR2DRECT				rcSource;					/* source rectangle; scaling is supported */
+	PPVR2D_SURFACE			pSrc2;						/* optional second source surface (NULL if not required) */
+	PVR2DRECT*				prcSource2;					/* optional pSrc2 rectangle */
+	PVR2D_HANDLE			hUseCode;					/* custom USSE shader code (NULL implies default source copy) */
+	PVR2D_ULONG				UseParams[2];				/* per-blt params for usse code */
+	PVR2D_ULONG				uiNumTemporaryRegisters;	/* no. of temporary registers used in custom shader code */
+	PVR2D_BOOL				bDisableDestInput;			/* set true if the destination is output only */
+	PPVR2D_SURFACE_EXT		pDstExt;					/* Extended format params for dest */
+	PPVR2D_SURFACE_EXT		pSrcExt[2];					/* Extended format params for source 1 and 2 */
+	PVR2D_LONG				Reserved[4];				/* Reserved, must be zero */
+
+} PVR2D_3DBLT_EXT, *PPVR2D_3DBLT_EXT;
+
+
+#define MAKE_COPY_BLIT(src,soff,dest,doff,sx,sy,dx,dy,sz)
+
+typedef void* PVR2DCONTEXTHANDLE;
+typedef void* PVR2DFLIPCHAINHANDLE;
+
+
+// CopyCode field of PVR2DBLTINFO structure:
+// the CopyCode field of the PVR2DBLTINFO structure should contain a rop3 or rop4 code.
+// a rop3 is an 8 bit code that describes a blt with three inputs : source dest and pattern
+// rop4 is a 16 bit code that describes a blt with four inputs : source dest pattern and mask
+// common rop3 codes are defined below
+// a colour fill blt is processed in the pattern channel as a constant colour with a rop code of 0xF0
+// PVR2D_BLIT_PAT_SURFACE_ENABLE defines whether the pattern channel is a surface or a fill colour.
+// a rop4 is defined by two rop3 codes, and the 1 bit-per-pixel mask surface defines which is used.
+// a common rop4 is 0xAAF0 which is the mask copy blt used for text glyphs.
+// CopyCode is taken to be a rop4 when pMaskMemInfo is non zero, otherwise it is assumed to be a rop3
+// use the PVR2DMASKROP4 macro below to construct a rop4 from two rop3's
+// rop3a is the rop used when mask pixel = 1, and rop3b when mask = 0
+#define PVR2DROP4(rop3b, rop3a)			((rop3b<<8)|rop3a)
+
+/* common rop codes */
+#define PVR2DROPclear				0x00       /* 0 (whiteness) */
+#define PVR2DROPset					0xFF       /* 1 (blackness) */
+#define PVR2DROPnoop				0xAA       /* dst (used for masked blts) */
+
+/* source and  dest rop codes */
+#define PVR2DROPand					0x88       /* src AND dst */
+#define PVR2DROPandReverse			0x44       /* src AND NOT dst */
+#define PVR2DROPcopy				0xCC       /* src (used for source copy and alpha blts) */
+#define PVR2DROPandInverted			0x22       /* NOT src AND dst */
+#define PVR2DROPxor					0x66       /* src XOR dst */
+#define PVR2DROPor					0xEE       /* src OR dst */
+#define PVR2DROPnor					0x11       /* NOT src AND NOT dst */
+#define PVR2DROPequiv				0x99       /* NOT src XOR dst */
+#define PVR2DROPinvert				0x55       /* NOT dst */
+#define PVR2DROPorReverse			0xDD       /* src OR NOT dst */
+#define PVR2DROPcopyInverted		0x33       /* NOT src */
+#define PVR2DROPorInverted			0xBB       /* NOT src OR dst */
+#define PVR2DROPnand				0x77       /* NOT src OR NOT dst */
+
+/* pattern rop codes */
+#define PVR2DPATROPand				0xA0       /* pat AND dst */
+#define PVR2DPATROPandReverse		0x50       /* pat AND NOT dst */
+#define PVR2DPATROPcopy				0xF0       /* pat (used for solid color fills and pattern blts) */
+#define PVR2DPATROPandInverted		0x0A       /* NOT pat AND dst */
+#define PVR2DPATROPxor				0x5A       /* pat XOR dst */
+#define PVR2DPATROPor				0xFA       /* pat OR dst */
+#define PVR2DPATROPnor				0x05       /* NOT pat AND NOT dst */
+#define PVR2DPATROPequiv			0xA5       /* NOT pat XOR dst */
+#define PVR2DPATROPinvert			0x55       /* NOT dst */
+#define PVR2DPATROPorReverse		0xF5       /* pat OR NOT dst */
+#define PVR2DPATROPcopyInverted		0x0F       /* NOT pat */
+#define PVR2DPATROPorInverted		0xAF       /* NOT pat OR dst */
+#define PVR2DPATROPnand				0x5F       /* NOT pat OR NOT dst */
+
+/* common rop4 codes */
+#define PVR2DROP4MaskedCopy              PVR2DROP4(PVR2DROPnoop,PVR2DROPcopy)		/* masked source copy blt (used for rounded window corners etc) */
+#define PVR2DROP4MaskedFill              PVR2DROP4(PVR2DROPnoop,PVR2DPATROPcopy)	/* masked colour fill blt (used for text) */
+
+/* Legacy support */
+#define PVR2DROP3_PATMASK			PVR2DPATROPcopy
+#define PVR2DROP3_SRCMASK			PVR2DROPcopy
+
+/* pixmap memory alignment */
+#define PVR2D_ALIGNMENT_4			4			/* DWORD alignment */
+#define PVR2D_ALIGNMENT_ANY			0			/* no alignment    */
+#define PVR2D_ALIGNMENT_PALETTE		16			/* 16 byte alignment is required for palettes */
+
+/* Heap number for PVR2DGetFrameBuffer */
+#define PVR2D_FB_PRIMARY_SURFACE 0
+
+#define PVR2D_PRESENT_PROPERTY_SRCSTRIDE	(1UL << 0)
+#define PVR2D_PRESENT_PROPERTY_DSTSIZE		(1UL << 1)
+#define PVR2D_PRESENT_PROPERTY_DSTPOS		(1UL << 2)
+#define PVR2D_PRESENT_PROPERTY_CLIPRECTS	(1UL << 3)
+#define PVR2D_PRESENT_PROPERTY_INTERVAL		(1UL << 4)
+
+#define PVR2D_CREATE_FLIPCHAIN_SHARED		(1UL << 0)
+#define PVR2D_CREATE_FLIPCHAIN_QUERY		(1UL << 1)
+#define PVR2D_CREATE_FLIPCHAIN_OEMOVERLAY   (1UL << 2)
+#define PVR2D_CREATE_FLIPCHAIN_AS_BLITCHAIN (1UL << 3)
+
+/* Colour-key colour must be translated into argb8888 format */
+#define CKEY_8888(P)		(P)
+#define CKEY_4444(P)		(((P&0xF000UL)<<16) | ((P&0x0F00UL)<<12) | ((P&0x00F0UL)<<8) | ((P&0x000FUL)<<4))
+#define CKEY_1555(P)		(((P&0x8000UL)<<16) | ((P&0x7C00UL)<<9)  | ((P&0x3E0UL)<<6)  | ((P&0x1FUL)<<3))
+#define CKEY_565(P)			(((P&0xF800UL)<<8)  | ((P&0x7E0UL)<<5)   | ((P&0x1FUL)<<3))
+#define CKEY_MASK_8888		0x00FFFFFFUL
+#define CKEY_MASK_4444		0x00F0F0F0UL
+#define CKEY_MASK_1555		0x00F8F8F8UL	/* Alpha is not normally included in the key test */
+#define CKEY_MASK_565		0x00F8FCF8UL
+
+/* Fill colours must be translated into argb8888 format */
+#define CFILL_4444(P)		(((P&0xF000UL)<<16) | ((P&0x0F00UL)<<12) | ((P&0x00F0UL)<<8) | ((P&0x000FUL)<<4))
+#define CFILL_1555(P)		(((P&0x8000UL)<<16) | ((P&0x7C00UL)<<9)  | ((P&0x3E0UL)<<6)  | ((P&0x1FUL)<<3))
+#define CFILL_565(P)		(((P&0xF800UL)<<8)  | ((P&0x7E0UL)<<5)   | ((P&0x1FUL)<<3))
+
+/* PVR2DCreateDeviceContext flags */
+#define PVR2D_XSERVER_PROC			0x00000001UL		/*!< Set for the Xserver connection */
+
+/* PVR2DMemAlloc flags */
+#define PVR2D_MEM_UNCACHED			0x00000000UL	/* Default */
+#define PVR2D_MEM_CACHED			0x00000001UL	/* Caller must flush and sync when necessary */
+#define PVR2D_MEM_WRITECOMBINE		0x00000002UL
+
+/* Functions that the library exports */
+
+PVR2D_IMPORT
+int PVR2DEnumerateDevices(PVR2DDEVICEINFO *pDevInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DCreateDeviceContext(PVR2D_ULONG ulDevID,
+									PVR2DCONTEXTHANDLE* phContext,
+									PVR2D_ULONG ulFlags);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DDestroyDeviceContext(PVR2DCONTEXTHANDLE hContext);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetDeviceInfo(PVR2DCONTEXTHANDLE hContext,
+							  PVR2DDISPLAYINFO *pDisplayInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetMiscDisplayInfo(PVR2DCONTEXTHANDLE hContext,
+							  PVR2DMISCDISPLAYINFO *pMiscDisplayInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetScreenMode(PVR2DCONTEXTHANDLE hContext,
+							  PVR2DFORMAT *pFormat,
+							  PVR2D_LONG *plWidth,
+							  PVR2D_LONG *plHeight,
+							  PVR2D_LONG *plStride,
+							  PVR2D_INT *piRefreshRate);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetFrameBuffer(PVR2DCONTEXTHANDLE hContext,
+							   PVR2D_INT nHeap,
+							   PVR2DMEMINFO **ppsMemInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DMemAlloc(PVR2DCONTEXTHANDLE hContext,
+						 PVR2D_ULONG ulBytes,
+						 PVR2D_ULONG ulAlign,
+						 PVR2D_ULONG ulFlags,
+						 PVR2DMEMINFO **ppsMemInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DMemExport(PVR2DCONTEXTHANDLE hContext,
+						 PVR2D_ULONG ulFlags,
+						 PVR2DMEMINFO *psMemInfo,
+						 PVR2D_HANDLE *phMemHandle);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DMemWrap(PVR2DCONTEXTHANDLE hContext,
+						PVR2D_VOID *pMem,
+						PVR2D_ULONG ulFlags,
+						PVR2D_ULONG ulBytes,
+						PVR2D_ULONG alPageAddress[],
+						PVR2DMEMINFO **ppsMemInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DMemMap(PVR2DCONTEXTHANDLE hContext,
+						PVR2D_ULONG ulFlags,
+						PVR2D_HANDLE hMemHandle,
+						PVR2DMEMINFO **ppsDstMem);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DMemFree(PVR2DCONTEXTHANDLE hContext,
+						PVR2DMEMINFO *psMemInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DBlt(PVR2DCONTEXTHANDLE hContext,
+					PVR2DBLTINFO *pBltInfo);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DBltClipped(PVR2DCONTEXTHANDLE hContext,
+						   PVR2DBLTINFO *pBltInfo,
+						   PVR2D_ULONG ulNumClipRects,
+						   PVR2DRECT *pClipRects);
+
+PVR2D_EXPORT
+PVR2DERROR PVR2DSet1555Alpha (PVR2DCONTEXTHANDLE hContext,
+							  PVR2D_UCHAR Alpha0, PVR2D_UCHAR Alpha1);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DQueryBlitsComplete(PVR2DCONTEXTHANDLE hContext,
+								   const PVR2DMEMINFO *pMemInfo,
+								   PVR2D_UINT uiWaitForComplete);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DSetPresentBltProperties(PVR2DCONTEXTHANDLE hContext,
+										PVR2D_ULONG ulPropertyMask,
+										PVR2D_LONG lSrcStride,
+										PVR2D_ULONG ulDstWidth,
+										PVR2D_ULONG ulDstHeight,
+										PVR2D_LONG lDstXPos,
+										PVR2D_LONG lDstYPos,
+										PVR2D_ULONG ulNumClipRects,
+										PVR2DRECT *pClipRects,
+										PVR2D_ULONG ulSwapInterval);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DPresentBlt(PVR2DCONTEXTHANDLE hContext,
+						   PVR2DMEMINFO *pMemInfo,
+						   PVR2D_LONG lRenderID);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DCreateFlipChain(PVR2DCONTEXTHANDLE hContext,
+								PVR2D_ULONG ulFlags,
+								PVR2D_ULONG ulNumBuffers,
+								PVR2D_ULONG ulWidth,
+								PVR2D_ULONG ulHeight,
+								PVR2DFORMAT eFormat,
+								PVR2D_LONG *plStride,
+								PVR2D_ULONG *pulFlipChainID,
+								PVR2DFLIPCHAINHANDLE *phFlipChain);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DDestroyFlipChain(PVR2DCONTEXTHANDLE hContext,
+								 PVR2DFLIPCHAINHANDLE hFlipChain);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetFlipChainBuffers(PVR2DCONTEXTHANDLE hContext,
+									PVR2DFLIPCHAINHANDLE hFlipChain,
+									PVR2D_ULONG *pulNumBuffers,
+									PVR2DMEMINFO *psMemInfo[]);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DSetPresentFlipProperties(PVR2DCONTEXTHANDLE hContext,
+										 PVR2DFLIPCHAINHANDLE hFlipChain,
+										 PVR2D_ULONG ulPropertyMask,
+										 PVR2D_LONG lDstXPos,
+										 PVR2D_LONG lDstYPos,
+										 PVR2D_ULONG ulNumClipRects, 
+										 PVR2DRECT *pClipRects,
+										 PVR2D_ULONG ulSwapInterval);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DPresentFlip(PVR2DCONTEXTHANDLE hContext,
+							PVR2DFLIPCHAINHANDLE hFlipChain,
+							PVR2DMEMINFO *psMemInfo,
+							PVR2D_LONG lRenderID);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DGetAPIRev(PVR2D_LONG *lRevMajor, PVR2D_LONG *lRevMinor);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DLoadUseCode (const PVR2DCONTEXTHANDLE hContext, const PVR2D_UCHAR	*pUseCode,
+									const PVR2D_ULONG UseCodeSize, PVR2D_HANDLE *pUseCodeHandle);
+PVR2D_IMPORT
+PVR2DERROR PVR2DFreeUseCode (const PVR2DCONTEXTHANDLE hContext, const PVR2D_HANDLE hUseCodeHandle);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DBlt3D (const PVR2DCONTEXTHANDLE hContext, const PPVR2D_3DBLT pBlt3D);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DBlt3DExt (const PVR2DCONTEXTHANDLE hContext, const PPVR2D_3DBLT_EXT pBlt3D);
+
+#ifdef __cplusplus
+}
+#endif 
+
+#endif /* _PVR2D_H_ */
+
+/******************************************************************************
+ End of file (pvr2d.h)
+******************************************************************************/
--- qt-everywhere-opensource-src-4.8.2_orig/src/3rdparty/powervr/wsegl.h	2012-04-27 04:46:12.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.2/src/3rdparty/powervr/wsegl.h	2012-06-16 13:05:48.320272285 +0900
@@ -1,13 +1,32 @@
-/******************************************************************************
- Name         : wsegl.h
- Copyright    :	Copyright (c) Imagination Technologies Limited.
-				This specification is protected by copyright laws and contains
-				material proprietary to Imagination Technologies Limited.
-				You may use and distribute this specification free of charge for implementing
-				the functionality therein, without altering or removing any trademark, copyright,
-				or other notice from the specification.
- Platform     : ANSI
-*****************************************************************************/
+/**********************************************************************
+*
+* Copyright(c) Imagination Technologies Ltd.
+*
+* The contents of this file are subject to the MIT license as set out below.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+* 
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
+* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+* OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+* 
+* This License is also included in this distribution in the file called 
+* "COPYING".
+* 
+******************************************************************************/
+
 
 
 #if !defined(__WSEGL_H__)
@@ -20,14 +39,19 @@
 /*
 // WSEGL Platform-specific definitions
 */
+#if defined(__linux__)
+#define WSEGL_EXPORT __attribute__((visibility("default")))
+#define WSEGL_IMPORT
+#else
 #define WSEGL_EXPORT
 #define WSEGL_IMPORT
+#endif
 
 /*
 // WSEGL API Version Number
 */
 
-#define WSEGL_VERSION 1
+#define WSEGL_VERSION 2
 #define WSEGL_DEFAULT_DISPLAY 0
 #define WSEGL_DEFAULT_NATIVE_ENGINE 0
 
@@ -79,10 +103,21 @@
 */
 typedef enum WSEGLPixelFormat_TAG
 {
-	WSEGL_PIXELFORMAT_565 = 0,
-	WSEGL_PIXELFORMAT_4444 = 1,
-	WSEGL_PIXELFORMAT_8888 = 2,
-	WSEGL_PIXELFORMAT_1555 = 3
+	/* These must not be re-ordered */
+	WSEGL_PIXELFORMAT_RGB565	= 0,
+	WSEGL_PIXELFORMAT_ARGB4444	= 1,
+	WSEGL_PIXELFORMAT_ARGB8888	= 2,
+	WSEGL_PIXELFORMAT_ARGB1555	= 3,
+	WSEGL_PIXELFORMAT_ABGR8888	= 4,
+	WSEGL_PIXELFORMAT_XBGR8888	= 5,
+
+	/* These are compatibility names only; new WSEGL
+	 * modules should not use them.
+	 */
+	WSEGL_PIXELFORMAT_565		= WSEGL_PIXELFORMAT_RGB565,
+	WSEGL_PIXELFORMAT_4444		= WSEGL_PIXELFORMAT_ARGB4444,
+	WSEGL_PIXELFORMAT_8888		= WSEGL_PIXELFORMAT_ARGB8888,
+	WSEGL_PIXELFORMAT_1555		= WSEGL_PIXELFORMAT_ARGB1555,
 
 } WSEGLPixelFormat;
 
@@ -143,8 +178,13 @@
 	WSEGL_BAD_NATIVE_PIXMAP = 4,
 	WSEGL_BAD_NATIVE_ENGINE = 5,
 	WSEGL_BAD_DRAWABLE = 6,
-	WSEGL_BAD_CONFIG = 7,
-	WSEGL_OUT_OF_MEMORY = 8
+	WSEGL_BAD_MATCH = 7,
+	WSEGL_OUT_OF_MEMORY = 8,
+
+	/* These are compatibility names only; new WSEGL
+	 * modules should not use them.
+	 */
+	WSEGL_BAD_CONFIG = WSEGL_BAD_MATCH,
 
 } WSEGLError; 
 
@@ -186,6 +226,7 @@
 	/* Private data for the drawable */
 	void			*hPrivateData;
 
+
 } WSEGLDrawableParams;
 
 
@@ -223,6 +264,10 @@
 
 	WSEGLError (*pfnWSEGL_GetDrawableParameters)(WSEGLDrawableHandle, WSEGLDrawableParams *, WSEGLDrawableParams *);
 
+	WSEGLError (*pfnWSEGL_ConnectDrawable)(WSEGLDrawableHandle);
+
+	WSEGLError (*pfnWSEGL_DisconnectDrawable)(WSEGLDrawableHandle);
+
 
 } WSEGL_FunctionTable;
 
--- qt-everywhere-opensource-src-4.8.2_orig/src/plugins/gfxdrivers/powervr/QWSWSEGL/pvrqwswsegl.c	2012-04-27 04:46:09.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.2/src/plugins/gfxdrivers/powervr/QWSWSEGL/pvrqwswsegl.c	2012-06-16 13:06:44.800273360 +0900
@@ -39,7 +39,7 @@
 **
 ****************************************************************************/
 
-#include <GLES/eglplatform.h>
+#include <EGL/eglplatform.h>
 #include <wsegl.h>
 #include <pvr2d.h>
 #include <string.h>
@@ -379,6 +379,20 @@
     return WSEGL_SUCCESS;
 }
 
+/* Function stub for ConnectDrawable() */
+static WSEGLError wseglConnectDrawable(WSEGLDrawableHandle hDrawable)
+{
+    WSEGL_UNREFERENCED_PARAMETER(hDrawable);
+    return WSEGL_SUCCESS;
+}
+
+/* Function stub for DisconnectDrawable() */
+static WSEGLError wseglDisconnectDrawable(WSEGLDrawableHandle hDrawable)
+{
+    WSEGL_UNREFERENCED_PARAMETER(hDrawable);
+    return WSEGL_SUCCESS;
+}
+
 static WSEGL_FunctionTable const wseglFunctions = {
     WSEGL_VERSION,
     wseglIsDisplayValid,
@@ -392,7 +406,9 @@
     wseglWaitNative,
     wseglCopyFromDrawable,
     wseglCopyFromPBuffer,
-    wseglGetDrawableParameters
+    wseglGetDrawableParameters,
+    wseglConnectDrawable,
+    wseglDisconnectDrawable
 };
 
 /* Return the table of WSEGL functions to the EGL implementation */
diff -urN qt-everywhere-opensource-src-4.8.2_orig/mkspecs/qws/linux-TIarmv7-sgx-g++/qmake.conf qt-everywhere-opensource-src-4.8.2/mkspecs/qws/linux-TIarmv7-sgx-g++/qmake.conf
--- qt-everywhere-opensource-src-4.8.2_orig/mkspecs/qws/linux-TIarmv7-sgx-g++/qmake.conf	1970-01-01 09:00:00.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.2/mkspecs/qws/linux-TIarmv7-sgx-g++/qmake.conf	2012-06-17 15:37:30.581273364 +0900
@@ -0,0 +1,61 @@
+#
+# qmake configuration for building with arm-linux-g++
+#
+
+include(../../common/linux.conf)
+include(../../common/gcc-base-unix.conf)
+include(../../common/g++-unix.conf)
+include(../../common/qws.conf)
+
+#User specific Path - To Be edited by User
+QT_INSTALL_DIR  = $$PWD/../../..
+SDK_PATH	= /opt/ti-sdk-am3517-evm-05.04.00.00/linux-devkit/arm-arago-linux-gnueabi
+SGX_SDK_ROOT    = /opt/Graphics_SDK_4_06_00_02
+
+# modifications to g++.conf
+QMAKE_CFLAGS_RELEASE	= -O3 -march=armv7-a -mtune=cortex-a8 -mfpu=neon -mfloat-abi=softfp
+QMAKE_CXXFLAGS_RELEASE	= -O3 -march=armv7-a -mtune=cortex-a8 -mfpu=neon -mfloat-abi=softfp
+QMAKE_CFLAGS_DEBUG	= -g -O0 -march=armv7-a -mtune=cortex-a8 -mfpu=neon -mfloat-abi=softfp
+QMAKE_CXXFLAGS_DEBUG	= -g -O0 -march=armv7-a -mtune=cortex-a8 -mfpu=neon -mfloat-abi=softfp
+QMAKE_LFLAGS		+= "-L/opt/ti-sdk-am3517-evm-05.04.00.00/linux-devkit/arm-arago-linux-gnueabi/usr/lib -Wl,-rpath-link,/opt/ti-sdk-am3517-evm-05.04.00.00/linux-devkit/arm-arago-linux-gnueabi/usr/lib -Wl,--hash-style=gnu"
+QMAKE_CC                = arm-arago-linux-gnueabi-gcc
+QMAKE_CXX               = arm-arago-linux-gnueabi-g++
+QMAKE_LINK              = arm-arago-linux-gnueabi-g++
+QMAKE_LINK_SHLIB        = arm-arago-linux-gnueabi-g++
+
+# modifications to linux.conf
+QMAKE_AR                = arm-arago-linux-gnueabi-ar cqs
+QMAKE_OBJCOPY           = arm-arago-linux-gnueabi-objcopy
+QMAKE_STRIP             = arm-arago-linux-gnueabi-strip
+
+#Do not edit beyond this
+
+QMAKE_INCDIR_OPENGL_ES2 = $$SGX_SDK_ROOT/GFX_Linux_SDK/OGLES2/SDKPackage/Builds/OGLES2/Include/
+QMAKE_INCDIR_OPENGL_ES2 += $$SGX_SDK_ROOT/GFX_Linux_SDK/OGLES/SDKPackage/Builds/OGLES/LinuxOMAP3/Include/
+QMAKE_INCDIR_OPENGL_ES2 += $$SGX_SDK_ROOT/include
+QMAKE_INCDIR_OPENGL_ES2 += $$SGX_SDK_ROOT/GFX_Linux_SDK/OGLES/SDKPackage/Builds/OGLES/Include/
+QMAKE_LIBDIR_OPENGL_ES2 = $$SGX_SDK_ROOT/gfx_rel_es3.x/ 
+QMAKE_LIBS_OPENGL_ES2   = -lEGL -lGLESv2 -lGLES_CM -lIMGegl -lsrv_um -lusc
+
+QMAKE_INCDIR_OPENGL     += $$SGX_SDK_ROOT/GFX_Linux_SDK/OGLES/SDKPackage/Builds/OGLES/Include/
+QMAKE_INCDIR_OPENGL     += $$SGX_SDK_ROOT/GFX_Linux_SDK/OGLES/SDKPackage/Builds/OGLES/LinuxOMAP3/Include/
+QMAKE_INCDIR_OPENGL	+= $$SGX_SDK_ROOT/include
+QMAKE_LIBDIR_OPENGL     = $$SGX_SDK_ROOT/gfx_rel_es3.x
+QMAKE_LIBDIR_OPENGL_QT  = $$SGX_SDK_ROOT/gfx_rel_es3.x
+QMAKE_LIBS_OPENGL_ES1   = -lEGL -lGLES_CM -lIMGegl -lsrv_um -lusc
+
+QMAKE_INCDIR_OPENVG     = $$SGX_SDK_ROOT/GFX_Linux_SDK/OVG/SDKPackage/Builds/OVG/Include/
+QMAKE_LIBDIR_OPENVG     = $$SGX_SDK_ROOT/gfx_rel_es3.x/
+QMAKE_LIBS_OPENVG       = -lEGL -lGLES_CM -lIMGegl -lsrv_um -lOpenVG -lOpenVGU
+
+QMAKE_INCDIR_EGL        = $$QMAKE_INCDIR_OPENGL
+QMAKE_INCDIR_EGL        += $$QT_INSTALL_DIR/src/3rdparty/powervr/
+QMAKE_INCDIR_POWERVR	+= $$QT_INSTALL_DIR/src/3rdparty/powervr/
+QMAKE_LIBDIR_EGL        = $$QMAKE_LIBDIR_OPENGL
+QMAKE_LIBS_EGL          = -lEGL -lIMGegl -lsrv_um -lGLES_CM -lusc
+
+QMAKE_INCDIR += $$QMAKE_INCDIR_OPENGL
+QMAKE_LIBDIR += $$QMAKE_LIBDIR_OPENGL
+QMAKE_LIBS = $$QMAKE_LIBS_OPENGL_ES1 -lts -lasound 
+
+load(qt_config)
diff -urN qt-everywhere-opensource-src-4.8.2_orig/mkspecs/qws/linux-TIarmv7-sgx-g++/qplatformdefs.h qt-everywhere-opensource-src-4.8.2/mkspecs/qws/linux-TIarmv7-sgx-g++/qplatformdefs.h
--- qt-everywhere-opensource-src-4.8.2_orig/mkspecs/qws/linux-TIarmv7-sgx-g++/qplatformdefs.h	1970-01-01 09:00:00.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.2/mkspecs/qws/linux-TIarmv7-sgx-g++/qplatformdefs.h	2011-08-05 16:01:47.000000000 +0900
@@ -0,0 +1,17 @@
+/*
+ *   qplatformdefs.h
+ *  
+ *   Copyright (C) 2010 Texas Instruments Incorporated - http://www.ti.com/
+ *     
+ *   This program is free software; you can redistribute it and/or modify 
+ *   it under the terms of the GNU Lesser General Public License as
+ *   published by the Free Software Foundation version 2.1 of the License.
+ *         
+ *   This program is distributed .as is. WITHOUT ANY WARRANTY of any kind,
+ *   whether express or implied; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   Lesser General Public License for more details.
+ *              
+ */
+
+#include "../../linux-g++/qplatformdefs.h"
--- qt-everywhere-opensource-src-4.8.2_orig/src/gui/embedded/qkbd_qws.cpp	2012-04-27 04:46:09.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.2/src/gui/embedded/qkbd_qws.cpp	2012-06-16 17:30:21.073610403 +0900
@@ -47,6 +47,7 @@
 #include <QFile>
 #include <QDataStream>
 #include <QStringList>
+#include <QSettings>
 
 #ifdef Q_WS_QWS
 #include "qwindowsystem_qws.h"
@@ -522,6 +523,17 @@
             quint8 testmods = d->m_modifiers;
             if (d->m_locks[0] /*CapsLock*/ && (m->flags & QWSKeyboard::IsLetter))
                 testmods ^= QWSKeyboard::ModShift;
+
+			/************************************************************************************/
+			if(( d->m_locks[1]/*NumLock On*/ ) && (( 71 <= m->keycode ) && ( 83 >= m->keycode )))
+			{
+				if( (74 != m->keycode) && (78 != m->keycode))
+				{
+				testmods ^= QWSKeyboard::ModShift;
+				}
+			}
+			/************************************************************************************/
+
             if (m->modifiers == testmods)
                 map_withmod = m;
         }
@@ -561,13 +573,33 @@
             quint8 &lock = d->m_locks[qtcode - Qt::Key_CapsLock];
             lock ^= 1;
 
-            switch (qtcode) {
-            case Qt::Key_CapsLock  : result = lock ? CapsLockOn : CapsLockOff; break;
-            case Qt::Key_NumLock   : result = lock ? NumLockOn : NumLockOff; break;
-            case Qt::Key_ScrollLock: result = lock ? ScrollLockOn : ScrollLockOff; break;
-            default                : break;
+			/************************************************************************************/
+			QSettings setting("/etc/qt_keyboard.ini", QSettings::IniFormat);
+			switch (qtcode) {
+			case Qt::Key_CapsLock  :
+				result = lock ? CapsLockOn : CapsLockOff;
+
+				setting.beginGroup("CapsLock");
+				setting.setValue("Status",d->m_locks[0]);
+				setting.endGroup();
+
+				break;
+			case Qt::Key_NumLock   :
+				result = lock ? NumLockOn : NumLockOff;
+
+				setting.beginGroup("NumLock");
+				setting.setValue("Status",d->m_locks[1]);
+				setting.endGroup();
+
+				break;
+			case Qt::Key_ScrollLock:
+				result = lock ? ScrollLockOn : ScrollLockOff;
+				break;
+			default                :
+				break;
             }
-        }
+			/************************************************************************************/
+		}
     } else if ((it->flags & QWSKeyboard::IsSystem) && it->special && first_press) {
         switch (it->special) {
         case QWSKeyboard::SystemReboot:
@@ -685,6 +717,13 @@
     }
     return result;
 }
+/************************************************************************************/
+void QWSKeyboardHandler::setLockState_exf(quint8 a_caps_lock, quint8 a_num_lock )
+{
+	d->m_locks[0] = a_caps_lock;
+	d->m_locks[1] = a_num_lock;
+}
+/************************************************************************************/
 
 QT_END_NAMESPACE
 
--- qt-everywhere-opensource-src-4.8.2_orig/src/gui/embedded/qkbd_qws.h	2012-04-27 04:46:09.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.2/src/gui/embedded/qkbd_qws.h	2012-06-16 17:30:21.073610403 +0900
@@ -84,6 +84,10 @@
     };
 
     KeycodeAction processKeycode(quint16 keycode, bool pressed, bool autorepeat);
+	
+	/***************************************************************/
+	void setLockState_exf(quint8 a_caps_lock, quint8 a_num_lock );
+	/***************************************************************/
 
 protected:
     int transformDirKey(int key);
--- qt-everywhere-opensource-src-4.8.2_orig/src/gui/embedded/qkbdtty_qws.cpp	2012-04-27 04:46:09.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.2/src/gui/embedded/qkbdtty_qws.cpp	2012-06-16 17:30:21.092400715 +0900
@@ -45,6 +45,7 @@
 
 #include <QSocketNotifier>
 #include <QStringList>
+#include <QSettings>
 
 #include <qplatformdefs.h>
 #include <private/qcore_unix_p.h> // overrides QT_OPEN
@@ -199,6 +200,25 @@
 
         if (!m_vt_qws)
             qWarning("Could not initialize virtual console switching");
+
+		/***************************************************************/
+		QSettings setting("/etc/qt_keyboard.ini", QSettings::IniFormat);
+		char caps_lock;
+		char num_lock;
+		char kbd_state;
+
+
+		setting.beginGroup("CapsLock");
+		caps_lock = setting.value("Status", 0).toInt();
+		setting.endGroup();
+		setting.beginGroup("NumLock");
+		num_lock = setting.value("Status", 0).toInt();
+		setting.endGroup();
+		kbd_state =( caps_lock << 2 ) + ( num_lock << 1 );
+		::ioctl(m_tty_fd, KDSETLED, kbd_state);
+		::ioctl(m_tty_fd, KDSKBLED, kbd_state);
+		m_handler->setLockState_exf(caps_lock,num_lock);
+		/***************************************************************/
 #endif
     } else {
         qWarning("Cannot open input device '%s': %s", qPrintable(dev), strerror(errno));
